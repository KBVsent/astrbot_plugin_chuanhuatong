<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ä¼ è¯ç­’ Â· å¸ƒå±€ç¼–è¾‘å™¨</title>
  <style>
    :root {
      --bg-color: #090b10;
      --panel-bg: #141722;
      --panel-border: rgba(255, 255, 255, 0.08);
      --accent-color: #4f9dff;
      --accent-hover: #75baff;
      --text-main: #e3ecff;
      --text-sub: #8b9bb4;
      --input-bg: rgba(0, 0, 0, 0.25);
      --success: #00d1b2;
      --danger: #ff4757;
    }

    * { box-sizing: border-box; outline: none; }

    body {
      margin: 0;
      background: var(--bg-color);
      font-family: "PingFang SC", "Microsoft YaHei", system-ui, sans-serif;
      color: var(--text-main);
      height: 100vh;
      overflow: hidden;
    }

    /* æ»šåŠ¨æ¡ç¾åŒ– */
    ::-webkit-scrollbar { width: 6px; height: 6px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.15); border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.25); }

    .app {
      display: flex;
      flex-direction: column;
      height: 100vh;
    }

    /* é¡¶éƒ¨å¯¼èˆª */
    header {
      flex: 0 0 60px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 24px;
      background: var(--panel-bg);
      border-bottom: 1px solid var(--panel-border);
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
      z-index: 10;
    }
    header h1 { font-size: 18px; margin: 0; font-weight: 600; letter-spacing: 1px; }
    header p { margin: 0; font-size: 12px; color: var(--text-sub); }

    .main {
      flex: 1;
      display: flex;
      overflow: hidden;
    }

    /* å·¦ä¾§èˆå°åŒºåŸŸ */
    .stage-area {
      flex: 1;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      background-image: 
        radial-gradient(circle at 1px 1px, rgba(255,255,255,0.05) 1px, transparent 0);
      background-size: 24px 24px;
      overflow: hidden;
      padding: 40px;
    }

    .stage-wrapper {
      box-shadow: 0 0 50px rgba(0,0,0,0.5);
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.1);
      transition: transform 0.1s;
    }

    #stage {
      position: relative;
      background-color: #000;
      background-image: var(--stage-bg, linear-gradient(135deg, #1e2538, #10141d));
      background-size: cover;
      background-position: center;
      overflow: hidden;
      border-radius: 12px;
    }

    /* èˆå°å†…çš„å…ƒç´  */
    .layer-box {
      position: absolute;
      border: 1px dashed rgba(255, 255, 255, 0.4);
      background: rgba(40, 150, 255, 0.15);
      color: #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: move;
      user-select: none;
      backdrop-filter: blur(2px);
      transition: border-color 0.2s, background 0.2s;
    }
    .layer-box:hover { border-color: var(--accent-color); background: rgba(40, 150, 255, 0.25); }
    .layer-box.selected { border: 2px solid var(--accent-color); z-index: 999 !important; box-shadow: 0 0 15px rgba(79, 157, 255, 0.3); }
    .layer-box img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      pointer-events: none;
      display: block;
    }
    .layer-box.image-layer { background: transparent; }
    .layer-box.image-layer img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      pointer-events: none;
      filter: drop-shadow(0 4px 18px rgba(0,0,0,0.45));
    }
    .layer-box.text-layer {
      display: block;
      padding: 0;
      white-space: pre-wrap;
      word-break: break-word;
      line-height: 1.25;
      text-align: left;
      background: transparent;
    }
    #textBox {
      display: block;
      background: transparent !important;
      backdrop-filter: none !important;
      -webkit-backdrop-filter: none !important;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .textbox-placeholder {
      display: block;
      white-space: pre-wrap;
      word-break: break-word;
    }
    
    .resize-handle {
      position: absolute;
      width: 12px;
      height: 12px;
      right: -6px;
      bottom: -6px;
      background: var(--accent-color);
      border-radius: 50%;
      cursor: nwse-resize;
      border: 2px solid #fff;
    }

    #characterHandle img {
      width: 100%; height: 100%; object-fit: contain; pointer-events: none;
      filter: drop-shadow(0 10px 20px rgba(0,0,0,0.5));
    }
    
    /* å³ä¾§æ§åˆ¶é¢æ¿ */
    .panel {
      flex: 0 0 340px;
      background: var(--panel-bg);
      border-left: 1px solid var(--panel-border);
      display: flex;
      flex-direction: column;
      overflow-y: auto;
    }

    .panel-section {
      border-bottom: 1px solid var(--panel-border);
    }
    
    .panel-header {
      padding: 12px 16px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: 600;
      font-size: 13px;
      color: var(--text-main);
      background: rgba(255,255,255,0.02);
      transition: background 0.2s;
    }
    .panel-header:hover { background: rgba(255,255,255,0.05); }
    .panel-header::after {
      content: 'â–¼';
      font-size: 10px;
      color: var(--text-sub);
      transition: transform 0.2s;
    }
    .panel-section.collapsed .panel-header::after { transform: rotate(-90deg); }
    .panel-content { padding: 12px 16px; display: block; }
    .panel-section.collapsed .panel-content { display: none; }

    /* è¡¨å•æ§ä»¶ */
    .form-group { margin-bottom: 10px; }
    label { display: block; font-size: 12px; color: var(--text-sub); margin-bottom: 4px; }
    
    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    
    input[type="text"], input[type="number"], select {
      width: 100%;
      background: var(--input-bg);
      border: 1px solid var(--panel-border);
      color: var(--text-main);
      padding: 6px 8px;
      border-radius: 4px;
      font-size: 12px;
      transition: border-color 0.2s;
    }
    input:focus, select:focus { border-color: var(--accent-color); }
    
    input[type="color"] {
      width: 100%; height: 28px; border: none; padding: 0; background: transparent; cursor: pointer;
    }

    /* æŒ‰é’®æ ·å¼ */
    .btn-group { display: flex; gap: 8px; margin-top: 12px; }
    button {
      flex: 1;
      padding: 8px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      font-weight: 600;
      transition: filter 0.2s, transform 0.1s;
    }
    button:active { transform: translateY(1px); }
    
    button:disabled { opacity: 0.45; cursor: not-allowed; }
    
    .btn-primary { background: var(--accent-color); color: #000; }
    .btn-primary:hover { filter: brightness(1.1); }
    
    .btn-secondary { background: rgba(255,255,255,0.1); color: var(--text-main); }
    .btn-secondary:hover { background: rgba(255,255,255,0.15); }
    
    .btn-ghost {
      background: rgba(255,255,255,0.03);
      color: var(--text-main);
      border: 1px dashed rgba(255,255,255,0.2);
    }
    .btn-ghost:hover { background: rgba(255,255,255,0.07); }
    
    .btn-danger { background: rgba(255, 71, 87, 0.15); color: var(--danger); border: 1px solid rgba(255, 71, 87, 0.3); }
    .btn-danger:hover { background: rgba(255, 71, 87, 0.25); }
    
    .preset-row { display:flex; gap:8px; margin-bottom:8px; }
    .preset-status { font-size: 12px; color: var(--text-sub); margin-bottom: 6px; min-height: 16px; }
    .preset-actions { display:flex; gap:8px; margin-bottom:8px; }
    
    .upload-grid {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .upload-card {
      background: rgba(255,255,255,0.02);
      border: 1px solid rgba(255,255,255,0.06);
      border-radius: 8px;
      padding: 12px;
    }
    .upload-card h4 {
      margin: 0 0 4px;
      font-size: 13px;
      font-weight: 600;
      color: var(--text-main);
    }
    .upload-card p {
      margin: 0 0 8px;
      font-size: 12px;
      color: var(--text-sub);
    }
    .upload-controls {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
    .upload-controls input[type="file"] {
      flex: 1;
      min-width: 0;
    }
    .upload-select-row {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
    }

    /* å›¾å±‚åˆ—è¡¨ç¾åŒ– */
    .layer-list {
      display: flex; flex-direction: column; gap: 4px; 
      max-height: 250px; overflow-y: auto;
      background: rgba(0,0,0,0.2); padding: 4px; border-radius: 6px;
    }
    .layer-item {
      display: flex; align-items: center; gap: 8px;
      padding: 6px 8px;
      background: rgba(255,255,255,0.03);
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
      border: 1px solid transparent;
    }
    .layer-item:hover { background: rgba(255,255,255,0.06); }
    .layer-item.active { border-color: var(--accent-color); background: rgba(79, 157, 255, 0.1); }
    .layer-icon { opacity: 0.7; font-size: 14px; }
    .layer-name { flex: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .layer-meta { font-family: monospace; opacity: 0.5; font-size: 10px; }

    /* å¼€å…³æ§ä»¶ */
    .toggle-row { display: flex; align-items: center; gap: 8px; margin-top: 4px; cursor: pointer; }
    .toggle-row span { font-size: 12px; color: var(--text-sub); }

    /* ï¼ˆæ—§ï¼‰æ–‡ä»¶ä¸Šä¼ æ ·å¼ä¿ç•™å¤‡ç”¨ */
    .preset-row select { flex:1; }
    .helper-text { font-size:12px; color: var(--text-sub); margin-top:4px; }

    #status {
      padding: 8px 16px; font-size: 12px; text-align: center; color: var(--text-sub);
    }
  </style>
</head>
<body>

  <div class="app">
    <header>
      <div>
        <h1>ä¼ è¯ç­’</h1>
        <p>Rich Text Layout Editor</p>
      </div>
      <div style="display:flex; gap:10px;">
        <button class="btn-secondary" id="previewBtn">ç”Ÿæˆé¢„è§ˆ</button>
        <button class="btn-secondary" id="resetBtn">é‡ç½®</button>
        <button class="btn-primary" id="saveDefaultBtn">ä¿å­˜é»˜è®¤å¸ƒå±€</button>
      </div>
    </header>

    <div class="main">
      <div class="stage-area">
        <div class="stage-wrapper">
          <div id="stage">
            <div id="characterHandle" class="layer-box" style="border-style:dotted; background:none;">
              <img id="charPreview" alt="" />
              <div class="resize-handle"></div>
            </div>
            
            <div id="textBox" class="layer-box">
              <span class="textbox-placeholder">ä¸»æ–‡æœ¬åŒºåŸŸ</span>
              <div class="resize-handle"></div>
            </div>

            <div id="overlayContainer"></div>

          </div>
        </div>
      </div>

      <div class="panel">
        <div id="status"></div>
        <div class="panel-section">
          <div class="panel-header" onclick="this.parentElement.classList.toggle('collapsed')">é¢„è®¾ç®¡ç†</div>
          <div class="panel-content">
            <div class="preset-status" id="presetStatus">å½“å‰é¢„è®¾ï¼šæœªåº”ç”¨ï¼ˆç¼–è¾‘é»˜è®¤å¸ƒå±€ï¼‰</div>
            <div class="preset-row">
              <select id="presetSelect">
                <option value="">é€‰æ‹©ä¸€ä¸ªé¢„è®¾</option>
              </select>
              <button class="btn-secondary" id="loadPresetBtn">åº”ç”¨é¢„è®¾</button>
            </div>
            <div class="preset-actions">
              <button class="btn-ghost" id="overridePresetBtn" disabled>è¦†ç›–å½“å‰é¢„è®¾</button>
              <button class="btn-primary" id="savePresetBtn">å¦å­˜ä¸ºé¢„è®¾</button>
            </div>
            <p class="helper-text">ä¹Ÿå¯ä»¥åœ¨å¯¹è¯é‡Œå‘é€â€œ/åˆ‡æ¢é¢„è®¾ åç§°â€å¿«é€Ÿåˆ‡æ¢ã€‚</p>
          </div>
        </div>

        <div class="panel-section">
          <div class="panel-header" onclick="this.parentElement.classList.toggle('collapsed')">ç”»å¸ƒä¸èƒŒæ™¯</div>
          <div class="panel-content">
            <div class="grid-2">
              <div><label>å®½ (px)</label><input type="number" data-field="canvas_width" min="400"></div>
              <div><label>é«˜ (px)</label><input type="number" data-field="canvas_height" min="400"></div>
            </div>
            <div class="grid-2">
              <div><label>èƒŒæ™¯è‰²</label><input type="color" id="backgroundColorInput"></div>
              <div><label>èƒŒæ™¯å›¾</label><select id="backgroundAssetSelect"></select></div>
            </div>
          </div>
        </div>

        <div class="panel-section collapsed">
          <div class="panel-header" onclick="this.parentElement.classList.toggle('collapsed')">ç«‹ç»˜ (Character)</div>
          <div class="panel-content">
            <label>è§’è‰²åˆ†ç»„</label>
            <select id="characterRoleSelect" data-field="character_role">
              <option value="__auto__">è‡ªåŠ¨åŒ¹é…ï¼ˆå…¨éƒ¨è§’è‰²ï¼‰</option>
            </select>
            <p class="helper-text">é€‰æ‹©è§’è‰²ç»„åä¼šè‡ªåŠ¨è®°å½•åœ¨é¢„è®¾ä¸­ï¼Œæ¸²æŸ“æ—¶æŒ‰æƒ…ç»ªåŒ¹é…è¯¥è§’è‰²çš„å·®åˆ†ã€‚</p>
            <label>é¢„è§ˆç«‹ç»˜</label>
            <select id="characterAssetSelect"></select>
            <div class="grid-2">
              <div><label>å·¦è¾¹è·</label><input type="number" data-field="character_left"></div>
              <div><label>åº•è¾¹è·</label><input type="number" data-field="character_bottom"></div>
              <div><label>å®½åº¦</label><input type="number" data-field="character_width"></div>
              <div><label>å±‚çº§ (Z)</label><input type="number" data-field="character_z_index"></div>
            </div>
          </div>
        </div>

        <div class="panel-section">
          <div class="panel-header" onclick="this.parentElement.classList.toggle('collapsed')">ä¸»æ–‡æœ¬æ¡†</div>
          <div class="panel-content">
            <div class="grid-2">
              <div><label>X</label><input type="number" data-field="box_left"></div>
              <div><label>Y</label><input type="number" data-field="box_top"></div>
              <div><label>W</label><input type="number" data-field="box_width"></div>
              <div><label>H</label><input type="number" data-field="box_height"></div>
            </div>
            <div class="grid-2">
              <div><label>åœ†è§’</label><input type="number" data-field="radius"></div>
              <div><label>å†…è¾¹è·</label><input type="number" data-field="padding"></div>
              <div><label>å­—å·</label><input type="number" data-field="font_size"></div>
              <div><label>è¡Œé«˜</label><input type="number" data-field="line_height" step="0.1"></div>
            </div>
            <div class="grid-2">
              <div><label>å­—ä½“</label><select id="bodyFontSelect"></select></div>
              <div><label>é¢œè‰²</label><input type="color" id="textColorInput"></div>
            </div>
            <div class="grid-2">
              <div><label>æè¾¹å®½åº¦</label><input type="number" data-field="text_stroke_width" min="0" value="0"></div>
              <div><label>æè¾¹é¢œè‰²</label><input type="color" data-field="text_stroke_color" value="#000000"></div>
            </div>
          </div>
        </div>


        <div class="panel-section">
          <div class="panel-header" onclick="this.parentElement.classList.toggle('collapsed')">å›¾å±‚ç®¡ç†</div>
          <div class="panel-content">
            <div class="layer-list" id="layerList">
              </div>
            <div class="btn-group">
              <button class="btn-secondary" id="addOverlayBtn">+ æ–‡æœ¬å±‚</button>
              <button class="btn-secondary" id="addGlassBtn">+ æ¯›ç»ç’ƒå±‚</button>
              <button class="btn-secondary" id="addImageOverlayBtn">+ ç»„ä»¶å±‚</button>
            </div>
            
            <div id="overlayEditor" style="display:none; margin-top:12px; border-top:1px solid var(--panel-border); padding-top:12px;">
              <div style="display:flex; justify-content:space-between; margin-bottom:8px;">
                <label style="color:var(--accent-color)">ç¼–è¾‘é€‰ä¸­å›¾å±‚</label>
                <button class="btn-danger" id="removeOverlayBtn" style="padding:2px 8px; flex:none;">åˆ é™¤</button>
              </div>
              
              <div id="overlayTypeControls">
                <label>å›¾å±‚ç±»å‹</label>
                <select id="overlayTypeSelect">
                  <option value="text">æ–‡æœ¬å±‚</option>
                  <option value="glass">æ¯›ç»ç’ƒå±‚</option>
                  <option value="image">ç»„ä»¶å±‚</option>
                </select>
              </div>

              <div id="overlayTextFields" style="display:none;">
                <label>å†…å®¹ / æ–‡æœ¬</label>
                <textarea id="overlayTextInput" rows="3" style="width:100%;"></textarea>
              </div>
              
              <div id="overlayImageFields" style="display:none;">
                <label>ç»„ä»¶ç´ æ</label>
                <select id="overlayImageSelect"></select>
              </div>

              <div class="grid-2" style="margin-top:8px;">
                <div><label>X</label><input type="number" id="overlayLeftInput"></div>
                <div><label>Y</label><input type="number" id="overlayTopInput"></div>
                <div><label>W</label><input type="number" id="overlayWidthInput"></div>
                <div><label>H</label><input type="number" id="overlayHeightInput"></div>
                <div><label>Z-Index</label><input type="number" id="overlayZIndexInput"></div>
                <div><label>é€æ˜åº¦</label><input type="number" id="overlayOpacityInput" step="0.1" max="1"></div>
              </div>
              
              <div class="grid-2" id="overlayFontControls" style="display:none;">
                <div><label>å­—ä½“</label><select id="overlayFontSelect"></select></div>
                <div><label>å­—å·</label><input type="number" id="overlayFontSizeInput"></div>
                <div><label>é¢œè‰²</label><input type="color" id="overlayColorInput"></div>
                <div class="toggle-row"><input type="checkbox" id="overlayBoldInput" /><span>åŠ ç²—</span></div>
                <div><label>æè¾¹å®½åº¦</label><input type="number" id="overlayStrokeWidthInput" min="0"></div>
                <div><label>æè¾¹é¢œè‰²</label><input type="color" id="overlayStrokeColorInput" value="#000000"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="panel-section collapsed">
          <div class="panel-header" onclick="this.parentElement.classList.toggle('collapsed')">èµ„æºä¸Šä¼ </div>
          <div class="panel-content">
            <div class="upload-grid">
              <div class="upload-card">
                <h4>ç»„ä»¶ç´ æ</h4>
                <p>PNG / WebP / GIFï¼Œä¸Šä¼ åå¯åœ¨å›¾å±‚ç»„ä»¶ä¸­ä½¿ç”¨ã€‚</p>
                <div class="upload-controls">
                  <input type="file" id="componentUpload" accept=".png,.webp,.gif">
                  <button class="btn-secondary" id="uploadComponentBtn">ä¼ ç»„ä»¶</button>
                </div>
              </div>
              <div class="upload-card">
                <h4>å­—ä½“æ–‡ä»¶</h4>
                <p>TTF / OTFï¼Œä¸Šä¼ åå¯åœ¨ä¸»æ–‡æœ¬æ¡†æˆ–å›¾å±‚å­—ä½“ä¸‹æ‹‰ä¸­é€‰æ‹©ã€‚</p>
                <div class="upload-controls">
                  <input type="file" id="fontUpload" accept=".ttf,.otf">
                  <button class="btn-secondary" id="uploadFontBtn">ä¼ å­—ä½“</button>
                </div>
              </div>
              <div class="upload-card">
                <h4>ç«‹ç»˜è§’è‰²ä¸æƒ…ç»ª</h4>
                <p>å…ˆé€‰æ‹©è§’è‰²åˆ†ç»„ï¼ˆä»…è‹±æ–‡/æ•°å­—/ä¸‹åˆ’çº¿/è¿å­—ç¬¦ï¼‰ï¼Œå†é€‰æ‹©æƒ…ç»ªæˆ–è‡ªå®šä¹‰åç§°ã€‚</p>
                <div class="upload-select-row">
                  <select id="characterRoleUploadSelect" title="è¯·é€‰æ‹©ç«‹ç»˜æ‰€å±è§’è‰²åˆ†ç»„">
                    <option value="">è§’è‰²åˆ†ç»„</option>
                  </select>
                  <input type="text" id="characterRoleCustom" placeholder="è‡ªå®šä¹‰è§’è‰² (ä»…è‹±æ–‡)">
                </div>
                <div class="upload-select-row">
                  <select id="characterEmotionSelect" title="è¯·é€‰æ‹©è¯¥ç«‹ç»˜å¯¹åº”çš„æƒ…ç»ª/å·®åˆ†">
                    <option value="">æƒ…ç»ª / å·®åˆ†</option>
                  </select>
                  <input type="text" id="characterEmotionCustom" placeholder="è‡ªå®šä¹‰æƒ…ç»ª (å¯é€‰)">
                </div>
                <div class="upload-controls">
                  <input type="file" id="characterUpload" accept=".png,.webp">
                  <button class="btn-secondary" id="uploadCharacterBtn">ä¼ ç«‹ç»˜</button>
                </div>
                <p class="helper-text">æ–‡ä»¶å°†ä¿å­˜åˆ° data/.../characters/&lt;è§’è‰²&gt;/&lt;æƒ…ç»ª&gt;/</p>
              </div>
            </div>
          </div>
        </div>

      </div>
    </div>
  </div>

  <script>
    'use strict';
    
    // --- DOM Elements ---
    const stage = document.getElementById('stage');
    const stageWrapper = document.querySelector('.stage-wrapper');
    const textBox = document.getElementById('textBox');
    const textBoxPlaceholder = textBox ? textBox.querySelector('.textbox-placeholder') : null;
    const characterHandle = document.getElementById('characterHandle');
    const charPreview = document.getElementById('charPreview');
    const overlayContainer = document.getElementById('overlayContainer');
    const statusEl = document.getElementById('status');
    const layerList = document.getElementById('layerList');
    const overlayEditor = document.getElementById('overlayEditor');
    const removeOverlayBtn = document.getElementById('removeOverlayBtn');
    const presetSelect = document.getElementById('presetSelect');
    const loadPresetBtn = document.getElementById('loadPresetBtn');
    const savePresetBtn = document.getElementById('savePresetBtn');
    const overridePresetBtn = document.getElementById('overridePresetBtn');
    const presetStatus = document.getElementById('presetStatus');
    const saveDefaultBtn = document.getElementById('saveDefaultBtn');
    const characterRoleSelect = document.getElementById('characterRoleSelect');
    const characterRoleUploadSelect = document.getElementById('characterRoleUploadSelect');
    const characterRoleCustom = document.getElementById('characterRoleCustom');
    const characterEmotionSelect = document.getElementById('characterEmotionSelect');
    const characterEmotionCustom = document.getElementById('characterEmotionCustom');
    const characterUploadInput = document.getElementById('characterUpload');
    const componentUploadInput = document.getElementById('componentUpload');
    const fontUploadInput = document.getElementById('fontUpload');

    // Inputs
    const inputs = {
      bgColor: document.getElementById('backgroundColorInput'),
      bgAsset: document.getElementById('backgroundAssetSelect'),
      charAsset: document.getElementById('characterAssetSelect'),
      charRole: characterRoleSelect,
      textColor: document.getElementById('textColorInput'),
      bodyFont: document.getElementById('bodyFontSelect'),
      // Overlay inputs
      oText: document.getElementById('overlayTextInput'),
      oImage: document.getElementById('overlayImageSelect'),
      oLeft: document.getElementById('overlayLeftInput'),
      oTop: document.getElementById('overlayTopInput'),
      oWidth: document.getElementById('overlayWidthInput'),
      oHeight: document.getElementById('overlayHeightInput'),
      oZ: document.getElementById('overlayZIndexInput'),
      oOpacity: document.getElementById('overlayOpacityInput'),
      oFont: document.getElementById('overlayFontSelect'),
      oSize: document.getElementById('overlayFontSizeInput'),
      oColor: document.getElementById('overlayColorInput'),
      oBold: document.getElementById('overlayBoldInput'),
      oStrokeWidth: document.getElementById('overlayStrokeWidthInput'),
      oStrokeColor: document.getElementById('overlayStrokeColorInput'),
    };

    // --- State ---
    const token = new URLSearchParams(location.search).get('token') || '';
    const authHeader = token ? { 'Authorization': `Bearer ${token}` } : {};
    const suffix = token ? `?token=${encodeURIComponent(token)}` : '';

    function buildQueryUrl(path, extra = {}) {
      const params = new URLSearchParams();
      if(token) params.set('token', token);
      Object.entries(extra || {}).forEach(([key, value]) => {
        if(value !== undefined && value !== null && value !== '') {
          params.set(key, value);
        }
      });
      const qs = params.toString();
      return qs ? `${path}?${qs}` : path;
    }

    const state = {
      layout: {},
      overlays: [],
      components: [],
      fonts: [],
      backgrounds: [],
      characters: [],
      presets: [],
      roles: [],
      emotions: [],
      scale: 1,
      selectedOverlayId: null,
      activeLayerId: 'sys_box',
      dragging: null, // { type, id, startX, startY, initialParams }
      characterRatio: 1.8,
      currentPresetSlug: '',
      currentPresetName: '',
    };


    if(charPreview) {
      charPreview.addEventListener('load', () => {
        if(charPreview.naturalWidth > 0) {
          const ratio = charPreview.naturalHeight / charPreview.naturalWidth;
          if(Number.isFinite(ratio) && ratio > 0) {
            state.characterRatio = ratio;
            renderCanvas();
          }
        }
      });
    }

    // --- Helpers ---
    function setStatus(msg, err = false) {
      statusEl.textContent = msg;
      statusEl.style.color = err ? 'var(--danger)' : 'var(--success)';
      if(!err) setTimeout(() => statusEl.textContent = '', 3000);
    }
    const escapeHtml = (text = '') => text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    const formatCharacterLabel = (value) => {
      if(value === '__auto__') return 'è‡ªåŠ¨';
      if(value === '__random__') return 'éšæœº';
      if(value && value.startsWith('user::')) {
        const parts = value.split('::');
        const role = parts.length > 1 ? (parts[1] || 'custom') : 'custom';
        const emotion = parts.length > 2 ? (parts[2] || '') : '';
        const file = parts.length > 3 ? (parts[3] || '') : (parts[parts.length - 1] || '');
        const emotionPath = emotion ? `${emotion}/` : '';
        return `ç”¨æˆ·/${role}/${emotionPath}${file || 'æœªçŸ¥'}`;
      }
      return value || '';
    };
    function renderPresetOptions() {
      if(!presetSelect) return;
      presetSelect.innerHTML = '<option value="">é€‰æ‹©ä¸€ä¸ªé¢„è®¾</option>';
      state.presets.forEach(p => {
        const option = document.createElement('option');
        option.value = p.slug;
        const label = p.name || p.slug;
        option.textContent = p.slug === state.currentPresetSlug ? `${label}ï¼ˆå½“å‰ï¼‰` : label;
        presetSelect.appendChild(option);
      });
      presetSelect.value = state.currentPresetSlug || '';
    }

    function renderPresetStatus() {
      if(!presetStatus) return;
      if(state.currentPresetSlug) {
        const label = state.currentPresetName || state.currentPresetSlug;
        presetStatus.textContent = `å½“å‰é¢„è®¾ï¼š${label}ï¼ˆå·²ç»‘å®šè§’è‰²ç»„ï¼‰`;
      } else {
        presetStatus.textContent = 'å½“å‰é¢„è®¾ï¼šæœªåº”ç”¨ï¼ˆæ­£åœ¨ç¼–è¾‘é»˜è®¤å¸ƒå±€ï¼‰';
      }
      if(overridePresetBtn) {
        overridePresetBtn.disabled = !state.currentPresetSlug;
      }
    }

    function setCurrentPreset(preset) {
      state.currentPresetSlug = preset?.slug || '';
      state.currentPresetName = preset?.name || '';
      if(presetSelect) {
        presetSelect.value = state.currentPresetSlug || '';
      }
      renderPresetStatus();
    }

    function renderRoleOptions() {
      if(characterRoleSelect) {
        const fragments = [];
        fragments.push('<option value="__auto__">è‡ªåŠ¨åŒ¹é…ï¼ˆå…¨éƒ¨è§’è‰²ï¼‰</option>');
        state.roles.forEach(role => {
          const label = role.label || role.id;
          fragments.push(`<option value="${escapeHtml(role.id)}">${escapeHtml(label)}</option>`);
        });
        characterRoleSelect.innerHTML = fragments.join('');
        const currentRole = state.layout.character_role || '__auto__';
        characterRoleSelect.value = currentRole;
      }
      if(characterRoleUploadSelect) {
        characterRoleUploadSelect.innerHTML = '<option value="">è§’è‰²åˆ†ç»„</option>';
        state.roles
          .filter(role => role.source !== 'builtin')
          .forEach(role => {
            const option = document.createElement('option');
            option.value = role.id;
            option.textContent = role.label || role.id;
            characterRoleUploadSelect.appendChild(option);
          });
      }
    }

    async function savePresetLayout(name, successLabel) {
      const trimmed = (name || '').trim();
      if(!trimmed) {
        setStatus('é¢„è®¾åç§°ä¸èƒ½ä¸ºç©º', true);
        return;
      }
      state.layout.text_overlays = state.overlays;
      setStatus('æ­£åœ¨ä¿å­˜é¢„è®¾...');
      try {
        const res = await fetch(`/api/presets/save${suffix}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', ...authHeader },
          body: JSON.stringify({ name: trimmed, layout: state.layout })
        });
        if(!res.ok) {
          const msg = await res.text();
          throw new Error(msg || 'ä¿å­˜å¤±è´¥');
        }
        const data = await res.json();
        state.layout = data.layout || state.layout;
        if(!state.layout.character_role) state.layout.character_role = '__auto__';
        if(state.layout.character_role !== '__auto__') {
          state.layout.character_asset = '__auto__';
        }
        state.overlays = normalizeOverlays(state.layout.text_overlays);
        state.presets = data.presets || state.presets;
        setCurrentPreset(data.preset || { name: trimmed, slug: trimmed });
        renderPresetOptions();
        renderRoleOptions();
        syncInputsToState();
        renderLayerList();
        renderCanvas();
        updatePreviewImages();
        const finalLabel = successLabel || `é¢„è®¾ã€Œ${data?.preset?.name || trimmed}ã€ä¿å­˜æˆåŠŸ`;
        setStatus(finalLabel);
      } catch(err) {
        setStatus(err.message || 'ä¿å­˜å¤±è´¥', true);
      }
    }

    function normalizeOverlays(raw = []) {
      return (raw || [])
        .map(o => {
          const normalizedType = o.type === 'converted_text' ? 'text' : (o.type || 'text');
          return {
            ...o,
            type: normalizedType,
            stroke_width: Number(o.stroke_width ?? 0) || 0,
            stroke_color: o.stroke_color || '#000000'
          };
        })
        .filter(o => ['text', 'image', 'glass'].includes(o.type));
    }

    function renderEmotionOptions() {
      if(!characterEmotionSelect) return;
      characterEmotionSelect.innerHTML = '<option value="">æƒ…ç»ª / å·®åˆ†</option>';
      state.emotions.forEach(item => {
        const value = item.folder || item.key || '';
        if(!value) return;
        const label = item.key ? `${item.key} (${value})` : value;
        const option = document.createElement('option');
        option.value = value;
        option.textContent = label;
        characterEmotionSelect.appendChild(option);
      });
    }

    function updateEmotionInputState() {
      if(!characterEmotionCustom) return;
      const locked = characterEmotionSelect && characterEmotionSelect.value;
      characterEmotionCustom.disabled = !!locked;
      if(locked) {
        characterEmotionCustom.value = '';
        characterEmotionCustom.placeholder = 'å·²é€‰æ‹©æƒ…ç»ª';
      } else {
        characterEmotionCustom.placeholder = 'è‡ªå®šä¹‰æƒ…ç»ª (å¯é€‰)';
      }
    }

    function updateRoleInputState() {
      if(!characterRoleCustom) return;
      const locked = characterRoleUploadSelect && characterRoleUploadSelect.value;
      characterRoleCustom.disabled = !!locked;
      if(locked) {
        characterRoleCustom.value = '';
        characterRoleCustom.placeholder = 'å·²é€‰æ‹©è§’è‰²';
      } else {
        characterRoleCustom.placeholder = 'è‡ªå®šä¹‰è§’è‰² (ä»…è‹±æ–‡)';
      }
    }

    function resolveSelectedRoleSlug() {
      const selected = characterRoleUploadSelect && characterRoleUploadSelect.value ? characterRoleUploadSelect.value.trim() : '';
      const customEnabled = characterRoleCustom && !characterRoleCustom.disabled;
      const custom = customEnabled ? (characterRoleCustom.value || '').trim() : '';
      return custom || selected || '';
    }

    function resolveSelectedEmotionSlug() {
      const selected = characterEmotionSelect && characterEmotionSelect.value ? characterEmotionSelect.value.trim() : '';
      const customEnabled = characterEmotionCustom && !characterEmotionCustom.disabled;
      const custom = customEnabled ? (characterEmotionCustom.value || '').trim() : '';
      return custom || selected || '';
    }

    const getUrl = (name, type) => {
      if(!name) return '';
      if(type === 'bg') return `/api/backgrounds/raw/${encodeURIComponent(name)}${suffix}`;
      if(type === 'char') return `/api/characters/raw/${encodeURIComponent(name)}${suffix}`;
      if(type === 'font') return `/api/fonts/raw/${encodeURIComponent(name)}${suffix}`;
      return `/api/components/raw/${encodeURIComponent(name)}${suffix}`;
    };

    // åŠ¨æ€åŠ è½½å­—ä½“
    const loadedFonts = new Set();
    function loadFont(fontName) {
      if(!fontName || loadedFonts.has(fontName)) return;
      if(!state.fonts.includes(fontName)) return; // ä¸æ˜¯è‡ªå®šä¹‰å­—ä½“ï¼Œä½¿ç”¨ç³»ç»Ÿå­—ä½“
      
      // æ£€æŸ¥æ˜¯å¦å·²ç»åŠ è½½
      const fontId = `font-${fontName.replace(/[^a-zA-Z0-9]/g, '-')}`;
      if(document.getElementById(fontId)) return;
      
      // åˆ›å»º@font-face
      const style = document.createElement('style');
      style.id = fontId;
      const ext = fontName.split('.').pop().toLowerCase();
      const fontFormat = ext === 'otf' ? 'opentype' : 'truetype';
      style.textContent = `
        @font-face {
          font-family: "${fontName}";
          src: url("${getUrl(fontName, 'font')}") format("${fontFormat}");
        }
      `;
      document.head.appendChild(style);
      loadedFonts.add(fontName);
    }

    // --- Core Logic ---

    async function init() {
      try {
        setStatus('æ­£åœ¨åŠ è½½é…ç½®...');
        const res = await fetch(`/api/config${suffix}`, { headers: authHeader });
        if(!res.ok) throw new Error('API Error');
        const data = await res.json();
        
        state.layout = data.layout || {};
        state.overlays = normalizeOverlays(state.layout.text_overlays);
        state.components = data.components || [];
        state.characters = data.characters || [];  // ç«‹ç»˜åˆ—è¡¨
        state.fonts = data.fonts || [];
        state.backgrounds = data.backgrounds || [];
        state.presets = data.presets || [];
        state.roles = data.character_roles || [];
        state.emotions = data.emotion_sets || [];
        if(!state.layout.character_role) state.layout.character_role = '__auto__';
        if(state.layout.character_role !== '__auto__') {
          state.layout.character_asset = '__auto__';
        }
        
        // Ensure defaults
        if(!state.layout.canvas_width) state.layout.canvas_width = 1280;
        if(!state.layout.canvas_height) state.layout.canvas_height = 720;

        state.currentPresetSlug = '';
        state.currentPresetName = '';
        setCurrentPreset(null);

        populateSelects();
        renderPresetOptions();
        renderRoleOptions();
        renderEmotionOptions();
        updateRoleInputState();
        updateEmotionInputState();
        syncInputsToState();
        renderCanvas();
        renderLayerList();
        renderPresetStatus();
        updatePreviewImages();
        setStatus('é…ç½®åŠ è½½æˆåŠŸ');
      } catch (e) {
        setStatus('åŠ è½½å¤±è´¥: ' + e.message, true);
        console.error(e);
      }
    }

    function populateSelects() {
      const makeOpts = (arr, extra = []) => 
        [...extra, ...arr].map(v => {
          const val = String(v);
          return `<option value="${escapeHtml(val)}">${escapeHtml(val)}</option>`;
        }).join('');
      
      inputs.bgAsset.innerHTML = makeOpts(state.backgrounds, ['__auto__', '__random__']);
      const charValues = ['__auto__', '__random__', ...state.characters];
      inputs.charAsset.innerHTML = charValues.map(v => {
        const val = String(v);
        return `<option value="${escapeHtml(val)}">${escapeHtml(formatCharacterLabel(val))}</option>`;
      }).join('');
      
      const fontOpts = makeOpts(state.fonts, ['']);
      inputs.bodyFont.innerHTML = fontOpts;
      if(inputs.oFont) inputs.oFont.innerHTML = fontOpts;
      
      inputs.oImage.innerHTML = makeOpts(state.components, ['']);
    }

    function syncInputsToState() {
      // Bind basic fields
      document.querySelectorAll('[data-field]').forEach(el => {
        const key = el.dataset.field;
        if(state.layout[key] !== undefined) el.value = state.layout[key];
      });

      inputs.bgColor.value = state.layout.background_color || '#000000';
      inputs.textColor.value = state.layout.text_color || '#ffffff';
      
      // Selects
      inputs.bgAsset.value = state.layout.background_asset || '__auto__';
      inputs.charAsset.value = state.layout.character_asset || '__auto__';
      inputs.bodyFont.value = state.layout.body_font || '';

      // åªåœ¨åˆå§‹åŒ–æ—¶æ›´æ–°é¢„è§ˆï¼Œä¸”åªåœ¨èµ„æºä¸æ˜¯auto/randomæ—¶æ›´æ–°
      const bg = state.layout.background_asset;
      const char = state.layout.character_asset;
      if(bg && bg !== '__auto__' && bg !== '__random__') {
        if(state.backgrounds.includes(bg)) {
          stage.style.backgroundImage = `url(${getUrl(bg, 'bg')})`;
        }
      }
      if(char && char !== '__auto__' && char !== '__random__' && state.characters.includes(char)) {
        const imgEl = document.getElementById('charPreview');
        if(imgEl) imgEl.src = getUrl(char, 'char');
      } else if(state.characters.length > 0) {
        const imgEl = document.getElementById('charPreview');
        if(imgEl && !imgEl.src) imgEl.src = getUrl(state.characters[0], 'char');
      }
    }

    let previewUpdateTimer = null;
    async function updatePreviewImages() {
       // é˜²æŠ–ï¼šé¿å…é¢‘ç¹è°ƒç”¨API
       if(previewUpdateTimer) {
         clearTimeout(previewUpdateTimer);
       }
       previewUpdateTimer = setTimeout(async () => {
         // Background preview
         const bg = state.layout.background_asset;
         if(bg && bg !== '__auto__' && bg !== '__random__') {
           if(state.backgrounds.includes(bg)) {
             stage.style.backgroundImage = `url(${getUrl(bg, 'bg')})`;
           } else if(state.components.includes(bg)) {
             stage.style.backgroundImage = `url(${getUrl(bg, 'comp')})`;
           }
         } else if(bg === '__auto__' || bg === '__random__') {
           // è°ƒç”¨APIè·å–éšæœºèƒŒæ™¯é¢„è§ˆï¼ˆåªåœ¨éœ€è¦æ—¶è°ƒç”¨ï¼‰
           try {
            const res = await fetch(buildQueryUrl('/api/preview-assets'), { headers: authHeader });
             if(res.ok) {
               const data = await res.json();
               if(data.background) {
                 stage.style.backgroundImage = `url(${data.background})`;
               }
             }
           } catch(e) { console.warn('Failed to load preview background', e); }
         }
         
         // Character preview - åªä½¿ç”¨ç«‹ç»˜åˆ—è¡¨
         const char = state.layout.character_asset;
         const imgEl = document.getElementById('charPreview');
         if(char && char !== '__auto__' && char !== '__random__' && state.characters.includes(char)) {
           imgEl.src = getUrl(char, 'char');
         } else if(char === '__auto__' || char === '__random__') {
           // è°ƒç”¨APIè·å–éšæœºç«‹ç»˜é¢„è§ˆï¼ˆåªåœ¨éœ€è¦æ—¶è°ƒç”¨ï¼‰
           try {
            const roleParam = state.layout.character_role && state.layout.character_role !== '__auto__'
              ? state.layout.character_role
              : '';
            const res = await fetch(
              buildQueryUrl('/api/preview-assets', roleParam ? { role: roleParam } : {}),
              { headers: authHeader }
            );
             if(res.ok) {
               const data = await res.json();
               if(data.character) {
                 imgEl.src = data.character;
               }
             }
           } catch(e) { console.warn('Failed to load preview character', e); }
         } else if(state.characters.length > 0 && !imgEl.src) {
           // é»˜è®¤è¯»å–ç¬¬ä¸€ä¸ªç«‹ç»˜
           imgEl.src = getUrl(state.characters[0], 'char');
         }
       }, 300); // 300msé˜²æŠ–
    }

    function renderCanvas() {
      const l = state.layout;
      
      // Stage dimensions
      stage.style.width = l.canvas_width + 'px';
      stage.style.height = l.canvas_height + 'px';
      stage.style.backgroundColor = l.background_color;

      // Scaling to fit
      const container = stageWrapper.getBoundingClientRect();
      const scaleX = (container.width - 40) / l.canvas_width;
      const scaleY = (container.height - 40) / l.canvas_height;
      state.scale = Math.min(scaleX, scaleY, 1);
      stage.style.transform = `scale(${state.scale})`;

      // Main Text Box
      const boxWidth = Math.max(20, Number(l.box_width) || 640);
      const boxHeight = Math.max(20, Number(l.box_height) || 340);
      const boxLeft = Number(l.box_left) || 520;
      const boxTop = Number(l.box_top) || 160;
      const padding = Math.max(0, Number(l.padding) || 20);
      const radius = Math.max(0, Number(l.radius) || 0);

      setPosSize(textBox, boxLeft, boxTop, boxWidth, boxHeight);
      textBox.style.borderRadius = radius + 'px';
      textBox.style.padding = padding + 'px';
      textBox.style.fontSize = (Number(l.font_size) || 24) + 'px';
      textBox.style.lineHeight = l.line_height || 1.5;
      textBox.style.color = l.text_color;
      // åŠ è½½å¹¶åº”ç”¨å­—ä½“
      if(l.body_font) {
        loadFont(l.body_font);
        textBox.style.fontFamily = `"${l.body_font}", "PingFang SC", "Microsoft YaHei", sans-serif`;
      } else {
        textBox.style.fontFamily = '"PingFang SC", "Microsoft YaHei", sans-serif';
      }
      const strokeWidth = Math.max(0, Number(l.text_stroke_width) || 0);
      const strokeColor = l.text_stroke_color || '#000000';
      if(strokeWidth > 0) {
        textBox.style.webkitTextStroke = `${strokeWidth}px ${strokeColor}`;
        textBox.style.textShadow = `0 0 ${Math.max(1, strokeWidth)}px ${strokeColor}`;
      } else {
        textBox.style.webkitTextStroke = '0px transparent';
        textBox.style.textShadow = 'none';
      }
      
      // æ›´æ–°é¢„è§ˆæ–‡æœ¬å†…å®¹
      if(textBoxPlaceholder) {
        textBoxPlaceholder.textContent = 'è¿™æ˜¯ä¸€æ®µç¤ºä¾‹æ–‡æœ¬ï¼Œç”¨äºé¢„è§ˆå¯¹è¯æ¡†æ•ˆæœã€‚ä½ å¯ä»¥åœ¨è¿™é‡Œçœ‹åˆ°æ–‡æœ¬çš„æ˜¾ç¤ºæ•ˆæœï¼ŒåŒ…æ‹¬å­—ä½“ã€é¢œè‰²ã€å¤§å°ç­‰è®¾ç½®ã€‚';
      }
      textBox.style.zIndex = l.textbox_z_index || 200;
      textBox.classList.toggle('selected', state.activeLayerId === 'sys_box');

      // Character
      const canvasW = Number(l.canvas_width) || 1280;
      const canvasH = Number(l.canvas_height) || 720;
      const { width: charWidth, height: charHeight } = getCharacterDimensions();
      const maxLeft = Math.max(0, canvasW - charWidth);
      const maxBottom = Math.max(0, canvasH - charHeight);
      l.character_left = Math.min(Math.max(0, Number(l.character_left) || 0), maxLeft);
      l.character_bottom = Math.min(Math.max(0, Number(l.character_bottom) || 0), maxBottom);
      characterHandle.style.left = l.character_left + 'px';
      characterHandle.style.bottom = l.character_bottom + 'px';
      characterHandle.style.width = charWidth + 'px';
      characterHandle.style.height = charHeight + 'px';
      characterHandle.style.top = 'auto';
      characterHandle.style.zIndex = l.character_z_index || 100;
      characterHandle.classList.toggle('selected', state.activeLayerId === 'sys_char');

      // åå­—å’Œè§’æ ‡å·²ç§»é™¤ï¼Œç”¨æˆ·éœ€è¦è‡ªå·±æ·»åŠ æ–‡æœ¬å±‚

      // Overlays
      renderOverlays();
    }

    function renderOverlays() {
      overlayContainer.innerHTML = '';
      state.overlays.forEach(o => {
        const el = document.createElement('div');
        const classes = ['layer-box'];
        if(state.activeLayerId === o.id) classes.push('selected');
        if(o.type === 'image') classes.push('image-layer');
        el.className = classes.join(' ');
        setPosSize(el, o.left, o.top, o.width, o.height);
        
        el.style.zIndex = o.z_index || 300;
        el.style.opacity = o.opacity !== undefined ? o.opacity : 1;

        if (o.type === 'image') {
          el.style.backgroundImage = '';
          el.style.backgroundColor = 'transparent';
          el.style.backdropFilter = 'none';
          if(o.image) {
            const img = document.createElement('img');
            img.src = getUrl(o.image, 'comp');
            img.alt = o.image || '';
            el.appendChild(img);
          } else {
            el.innerText = 'æœªé€‰æ‹©ç»„ä»¶';
          }
        } else if (o.type === 'glass') {
          // æ¯›ç»ç’ƒå±‚ï¼šæ˜¾ç¤ºä¸ºåŠé€æ˜æ¯›ç»ç’ƒæ•ˆæœ
          el.innerText = 'æ¯›ç»ç’ƒ';
          el.style.backgroundColor = 'rgba(255,255,255,0.1)';
          el.style.backdropFilter = 'blur(10px)';
          el.style.border = '1px solid rgba(255,255,255,0.2)';
          el.style.color = '#e3ecff';
          el.style.fontSize = '12px';
          el.style.display = 'flex';
          el.style.alignItems = 'center';
          el.style.justifyContent = 'center';
        } else {
          el.classList.add('text-layer');
          el.textContent = o.text || 'Text';
          el.style.fontSize = (o.font_size || 24) + 'px';
          el.style.color = o.color || '#ffffff';
          el.style.display = 'block';
          el.style.alignItems = '';
          el.style.justifyContent = '';
          el.style.whiteSpace = 'pre-wrap';
          el.style.wordBreak = 'break-word';
          // åŠ è½½å¹¶åº”ç”¨å­—ä½“
          const overlayFont = o.font || '';
          if(overlayFont && state.fonts.includes(overlayFont)) {
            loadFont(overlayFont);
            el.style.fontFamily = `"${overlayFont}", "PingFang SC", "Microsoft YaHei", sans-serif`;
          } else {
            el.style.fontFamily = overlayFont || '"PingFang SC", "Microsoft YaHei", sans-serif';
          }
          el.style.fontWeight = o.bold ? 'bold' : 'normal';
          el.style.lineHeight = '1.25';
          const strokeWidth = Math.max(0, Number(o.stroke_width) || 0);
          const strokeColor = o.stroke_color || '#000000';
          if(strokeWidth > 0) {
            el.style.webkitTextStroke = `${strokeWidth}px ${strokeColor}`;
            el.style.textShadow = `0 0 ${Math.max(1, strokeWidth)}px ${strokeColor}`;
          } else {
            el.style.webkitTextStroke = '0px transparent';
            el.style.textShadow = 'none';
          }
        }

        // Add Resize handle
        const resizer = document.createElement('div');
        resizer.className = 'resize-handle';
        el.appendChild(resizer);

        // Events
        el.onmousedown = (e) => {
          e.stopPropagation();
          state.activeLayerId = o.id;
          selectOverlay(o.id);
          if(e.target === resizer) startDrag('resize-overlay', e, o.id);
          else startDrag('move-overlay', e, o.id);
        };
        
        overlayContainer.appendChild(el);
      });
    }

    function renderLayerList() {
      layerList.innerHTML = '';
      
      // Combine base layers + overlays for the list, sorted by Z-index descending
      const layers = [
        { id: 'sys_char', name: 'ç«‹ç»˜ (Character)', z: state.layout.character_z_index || 100, icon: 'ğŸ‘¤' },
        { id: 'sys_box', name: 'ä¸»æ–‡æœ¬æ¡†', z: state.layout.textbox_z_index || 200, icon: 'ğŸ’¬' },
        ...state.overlays.map(o => {
          let name = '';
          let icon = 'ğŸ“';
          if (o.type === 'image') {
            name = `ç»„ä»¶: ${o.image || 'æœªé€‰æ‹©'}`;
            icon = 'ğŸ–¼ï¸';
          } else if (o.type === 'glass') {
            name = 'æ¯›ç»ç’ƒ';
            icon = 'ğŸ”²';
          } else {
            name = `æ–‡æœ¬: ${o.text || 'æœªå‘½å'}`;
            icon = 'ğŸ“';
          }
          return {
            id: o.id,
            name,
            z: o.z_index || 300,
            icon,
            isOverlay: true
          };
        })
      ].sort((a, b) => b.z - a.z);

      layers.forEach((l, idx) => {
        const div = document.createElement('div');
        const isActive = l.isOverlay ? state.selectedOverlayId === l.id : state.activeLayerId === l.id;
        div.className = `layer-item ${isActive ? 'active' : ''}`;
        div.dataset.layerId = l.id;
        div.dataset.layerIndex = idx;
        div.draggable = true;
        div.innerHTML = `
          <span class="layer-icon">${l.icon}</span>
          <span class="layer-name">${l.name}</span>
          <span class="layer-meta">z:${l.z}</span>
        `;
        div.onclick = () => {
           if(l.isOverlay) {
             selectOverlay(l.id);
           } else {
             state.selectedOverlayId = null;
             state.activeLayerId = l.id;
             overlayEditor.style.display = 'none';
             renderLayerList();
             renderCanvas();
           }
        };
        
        // æ‹–åŠ¨æ’åºåŠŸèƒ½
        div.ondragstart = (e) => {
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData('text/plain', l.id);
          div.classList.add('dragging');
          div.style.opacity = '0.5';
        };
        div.ondragend = (e) => { 
          div.classList.remove('dragging');
          div.style.opacity = '';
          // æ‹–åŠ¨ç»“æŸåé‡æ–°æ’åºæ‰€æœ‰å›¾å±‚
          reorderLayers();
        };
        div.ondragover = (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = 'move';
          const dragging = layerList.querySelector('.dragging');
          if(!dragging || dragging === div) return;
          const afterElement = getDragAfterElement(layerList, e.clientY);
          if(afterElement == null) {
            layerList.appendChild(dragging);
          } else {
            layerList.insertBefore(dragging, afterElement);
          }
        };
        div.ondrop = (e) => {
          e.preventDefault();
        };
        
        layerList.appendChild(div);
      });
      
      function getDragAfterElement(container, y) {
        const draggableElements = [...container.querySelectorAll('.layer-item:not(.dragging)')];
        return draggableElements.reduce((closest, child) => {
          const box = child.getBoundingClientRect();
          const offset = y - box.top - box.height / 2;
          if(offset < 0 && offset > closest.offset) {
            return { offset: offset, element: child };
          } else {
            return closest;
          }
        }, { offset: Number.NEGATIVE_INFINITY }).element;
      }
      
      function reorderLayers() {
        // é‡æ–°æ’åºæ‰€æœ‰å›¾å±‚çš„Z-index
        const allLayers = [...layerList.querySelectorAll('.layer-item')];
        allLayers.forEach((el, idx) => {
          const layerId = el.dataset.layerId;
          // ä»ä¸‹å¾€ä¸Šï¼ŒZ-indexé€’å¢ï¼ˆåˆ—è¡¨åº•éƒ¨ = æœ€ä¸Šå±‚ï¼‰
          const newZ = 100 + (allLayers.length - 1 - idx) * 10;
          
          if(layerId === 'sys_char') {
            state.layout.character_z_index = newZ;
          } else if(layerId === 'sys_box') {
            state.layout.textbox_z_index = newZ;
          } else if(layerId && layerId.startsWith('ov_')) {
            const overlay = state.overlays.find(o => o.id === layerId);
            if(overlay) {
              overlay.z_index = newZ;
            }
          }
        });
        // ç«‹å³æ›´æ–°é¢„è§ˆ
        renderCanvas();
        renderOverlays();
        renderLayerList();
      }
    }

    function selectOverlay(id) {
      state.selectedOverlayId = id;
      state.activeLayerId = id;
      const overlay = state.overlays.find(o => o.id === id);
      
      if(overlay) {
        overlayEditor.style.display = 'block';
        // Populate inputs
        inputs.oText.value = overlay.text || '';
        inputs.oImage.value = overlay.image || '';
        inputs.oLeft.value = overlay.left;
        inputs.oTop.value = overlay.top;
        inputs.oWidth.value = overlay.width;
        inputs.oHeight.value = overlay.height;
        inputs.oZ.value = overlay.z_index || 300;
        inputs.oOpacity.value = overlay.opacity !== undefined ? overlay.opacity : 1;
        inputs.oSize.value = overlay.font_size || 24;
        inputs.oColor.value = overlay.color || '#ffffff';
        if(inputs.oFont) inputs.oFont.value = overlay.font || '';
        if(inputs.oBold) inputs.oBold.checked = overlay.bold !== false;
        if(inputs.oStrokeWidth) inputs.oStrokeWidth.value = overlay.stroke_width || 0;
        if(inputs.oStrokeColor) inputs.oStrokeColor.value = overlay.stroke_color || '#000000';

        const typeControls = document.getElementById('overlayTypeControls');
        const fontControls = document.getElementById('overlayFontControls');
        const typeSelect = document.getElementById('overlayTypeSelect');
        const textFields = document.getElementById('overlayTextFields');
        const imageFields = document.getElementById('overlayImageFields');
        
        if(typeSelect) {
          typeSelect.value = overlay.type || 'text';
          typeSelect.disabled = false;
        }
        if(typeControls) {
          typeControls.style.display = 'block';
        }
        if(removeOverlayBtn) {
          removeOverlayBtn.disabled = false;
          removeOverlayBtn.title = '';
        }
        
        // æ ¹æ®å›¾å±‚ç±»å‹æ˜¾ç¤º/éšè—ç›¸åº”çš„é…ç½®é¡¹
        if(overlay.type === 'image') {
            if(textFields) textFields.style.display = 'none';
            if(imageFields) imageFields.style.display = 'block';
            if(fontControls) fontControls.style.display = 'none';
        } else if(overlay.type === 'glass') {
            if(textFields) textFields.style.display = 'none';
            if(imageFields) imageFields.style.display = 'none';
            if(fontControls) fontControls.style.display = 'none';
        } else {
            if(textFields) textFields.style.display = 'block';
            if(imageFields) imageFields.style.display = 'none';
            if(fontControls) fontControls.style.display = 'flex';
        }

      } else {
        overlayEditor.style.display = 'none';
      }
      renderOverlays();
      renderLayerList();
    }

    // --- Interaction ---

    function setPos(el, x, y) { el.style.left = x + 'px'; el.style.top = y + 'px'; }
    function setPosSize(el, x, y, w, h) { setPos(el, x, y); el.style.width = w + 'px'; el.style.height = h + 'px'; }
    function getCharacterDimensions() {
      const width = Math.max(20, Number(state.layout.character_width) || 520);
      const height = Math.max(20, width * (state.characterRatio || 1.8));
      return { width, height };
    }

    function updateFromInputs() {
      // æ³¨æ„ï¼šèƒŒæ™¯å’Œç«‹ç»˜èµ„æºä¸åœ¨inputäº‹ä»¶ä¸­æ›´æ–°ï¼Œåªåœ¨changeäº‹ä»¶ä¸­æ›´æ–°
      // è¿™æ ·å¯ä»¥é¿å…æ“ä½œå…¶ä»–å…ƒç´ æ—¶è§¦å‘é¢„è§ˆæ›´æ–°
      
      // Inputs to State
      document.querySelectorAll('[data-field]').forEach(el => {
        const key = el.dataset.field;
        state.layout[key] = parseFloat(el.value) || el.value;
      });

      // å…³é”®æ•°å€¼åšé™åˆ¶ï¼Œé¿å…å‡ºç°éæ³•å€¼
      state.layout.box_width = Math.max(20, Number(state.layout.box_width) || 640);
      state.layout.box_height = Math.max(20, Number(state.layout.box_height) || 340);
      state.layout.box_left = Number(state.layout.box_left) || 520;
      state.layout.box_top = Number(state.layout.box_top) || 160;
      state.layout.padding = Math.max(0, Number(state.layout.padding) || 20);
      state.layout.radius = Math.max(0, Number(state.layout.radius) || 0);
      state.layout.font_size = Math.max(8, Number(state.layout.font_size) || 24);
      state.layout.text_stroke_width = Math.max(0, Number(state.layout.text_stroke_width) || 0);
      state.layout.character_width = Math.max(50, Number(state.layout.character_width) || 520);
      state.layout.character_left = Math.max(0, Number(state.layout.character_left) || 0);
      state.layout.character_bottom = Math.max(0, Number(state.layout.character_bottom) || 0);

      state.layout.background_color = inputs.bgColor.value;
      // ä¸åœ¨è¿™é‡Œæ›´æ–°background_assetå’Œcharacter_assetï¼Œå®ƒä»¬ç”±changeäº‹ä»¶å¤„ç†
      state.layout.text_color = inputs.textColor.value;
      state.layout.body_font = inputs.bodyFont.value;

      renderCanvas();
      // ä¸åœ¨è¿™é‡Œè°ƒç”¨updatePreviewImages()ï¼Œé¿å…é—ªçƒ
    }
    
    // Bind all panel inputs
    // æ³¨æ„ï¼šbackgroundAssetSelectå’ŒcharacterAssetSelectä½¿ç”¨changeäº‹ä»¶ï¼Œé¿å…é¢‘ç¹è§¦å‘
    document.querySelectorAll('.panel input, .panel select, .panel textarea').forEach(el => {
      if(el.id.startsWith('overlay')) {
        el.addEventListener('input', updateOverlayFromInput);
      } else if(el.id === 'backgroundAssetSelect' || el.id === 'characterAssetSelect') {
        // è¿™äº›selectå·²ç»åœ¨ä¸Šé¢å•ç‹¬ç»‘å®šäº†changeäº‹ä»¶ï¼Œè¿™é‡Œè·³è¿‡
      } else {
        el.addEventListener('input', updateFromInputs);
      }
    });

    function updateOverlayFromInput() {
       if(!state.selectedOverlayId) return;
       const o = state.overlays.find(x => x.id === state.selectedOverlayId);
       if(!o) return;
       
       // å¤„ç†å›¾å±‚ç±»å‹å˜åŒ–
       const typeSelect = document.getElementById('overlayTypeSelect');
       if(typeSelect && typeSelect.value !== o.type) {
         o.type = typeSelect.value;
         // åˆ‡æ¢æ˜¾ç¤ºå­—æ®µ
         const textFields = document.getElementById('overlayTextFields');
         const imageFields = document.getElementById('overlayImageFields');
         const fontControls = document.getElementById('overlayFontControls');
         
         if(o.type === 'image') {
           if(textFields) textFields.style.display = 'none';
           if(imageFields) imageFields.style.display = 'block';
           if(fontControls) fontControls.style.display = 'none';
        } else if(o.type === 'glass') {
          // æ¯›ç»ç’ƒå±‚ï¼šåªæ˜¾ç¤ºä½ç½®å’Œå¤§å°
          if(textFields) textFields.style.display = 'none';
          if(imageFields) imageFields.style.display = 'none';
          if(fontControls) fontControls.style.display = 'none';
        } else {
           if(textFields) textFields.style.display = 'block';
           if(imageFields) imageFields.style.display = 'none';
           if(fontControls) fontControls.style.display = 'flex';
         }
       }
       
       o.text = inputs.oText.value;
       o.image = inputs.oImage.value;
       o.left = parseFloat(inputs.oLeft.value);
       o.top = parseFloat(inputs.oTop.value);
       o.width = parseFloat(inputs.oWidth.value);
       o.height = parseFloat(inputs.oHeight.value);
       o.z_index = parseFloat(inputs.oZ.value);
       o.opacity = parseFloat(inputs.oOpacity.value);
       o.font_size = parseFloat(inputs.oSize.value);
       o.color = inputs.oColor.value;
       if(inputs.oFont) o.font = inputs.oFont.value;
       if(inputs.oBold !== undefined) o.bold = inputs.oBold.checked;
       if(inputs.oStrokeWidth) o.stroke_width = Math.max(0, parseFloat(inputs.oStrokeWidth.value) || 0);
       if(inputs.oStrokeColor) o.stroke_color = inputs.oStrokeColor.value || '#000000';
       
       renderCanvas();
       renderLayerList(); // Update Z display
    }

    // Drag Logic
    function startDrag(type, e, id = null) {
      e.preventDefault();
      const rect = stage.getBoundingClientRect();
      const startX = (e.clientX - rect.left) / state.scale;
      const startY = (e.clientY - rect.top) / state.scale;
      
      let initialParams = {};
      
      if(type.includes('box')) {
        initialParams = { x: state.layout.box_left, y: state.layout.box_top, w: state.layout.box_width, h: state.layout.box_height };
      } else if (type.includes('overlay')) {
        const o = state.overlays.find(x => x.id === id);
        initialParams = { x: o.left, y: o.top, w: o.width, h: o.height };
      } else if (type === 'move-char') {
         initialParams = { x: state.layout.character_left || 0, bottom: state.layout.character_bottom || 0 };
      } else if (type === 'resize-char') {
         initialParams = { w: state.layout.character_width || 520 };
      }

      state.dragging = { type, id, startX, startY, initialParams };
      
      window.addEventListener('mousemove', onDrag);
      window.addEventListener('mouseup', stopDrag);
    }

    function onDrag(e) {
      if(!state.dragging) return;
      const rect = stage.getBoundingClientRect();
      const curX = (e.clientX - rect.left) / state.scale;
      const curY = (e.clientY - rect.top) / state.scale;
      const dx = curX - state.dragging.startX;
      const dy = curY - state.dragging.startY;
      const p = state.dragging.initialParams;
      const l = state.layout;

      switch(state.dragging.type) {
        case 'move-box':
          l.box_left = p.x + dx; l.box_top = p.y + dy;
          break;
        case 'resize-box':
          l.box_width = Math.max(50, p.w + dx); l.box_height = Math.max(50, p.h + dy);
          break;
        case 'move-char': {
          const canvasW = Number(l.canvas_width) || 1280;
          const canvasH = Number(l.canvas_height) || 720;
          const { width: charWidth, height: charHeight } = getCharacterDimensions();
          const maxLeft = Math.max(0, canvasW - charWidth);
          const maxBottom = Math.max(0, canvasH - charHeight);
          l.character_left = Math.min(Math.max(0, p.x + dx), maxLeft);
          const newBottom = p.bottom - dy;
          l.character_bottom = Math.min(Math.max(0, newBottom), maxBottom);
          break;
        }
        case 'resize-char': {
          const canvasW = Number(l.canvas_width) || 1280;
          const maxWidth = Math.max(50, canvasW - (Number(l.character_left) || 0));
          l.character_width = Math.min(Math.max(50, p.w + dx), maxWidth);
          const canvasH = Number(l.canvas_height) || 720;
          const { height: newCharHeight } = getCharacterDimensions();
          const maxBottom = Math.max(0, canvasH - newCharHeight);
          l.character_bottom = Math.min(Math.max(0, Number(l.character_bottom) || 0), maxBottom);
          break;
        }
        case 'move-overlay':
          const mo = state.overlays.find(x => x.id === state.dragging.id);
          if(mo) { mo.left = p.x + dx; mo.top = p.y + dy; selectOverlay(mo.id); }
          break;
        case 'resize-overlay':
          const ro = state.overlays.find(x => x.id === state.dragging.id);
          if(ro) { ro.width = Math.max(20, p.w + dx); ro.height = Math.max(20, p.h + dy); selectOverlay(ro.id); }
          break;
      }
      
      syncInputsToState();
      renderCanvas();
    }

    function stopDrag() {
      state.dragging = null;
      window.removeEventListener('mousemove', onDrag);
      window.removeEventListener('mouseup', stopDrag);
    }

    // --- Element Binding ---
    textBox.onmousedown = (e) => {
       state.selectedOverlayId = null;
       state.activeLayerId = 'sys_box';
       overlayEditor.style.display = 'none';
       renderLayerList();
       if(e.target.classList.contains('resize-handle')) startDrag('resize-box', e);
       else startDrag('move-box', e);
    };
    characterHandle.onmousedown = (e) => {
       state.selectedOverlayId = null;
       state.activeLayerId = 'sys_char';
       overlayEditor.style.display = 'none';
       renderLayerList();
       if(e.target.classList.contains('resize-handle')) startDrag('resize-char', e);
       else startDrag('move-char', e);
    };

    // --- Buttons ---
    document.getElementById('addOverlayBtn').onclick = () => {
      const id = 'ov_' + Date.now();
      state.overlays.push({ 
        id, 
        type: 'text', 
        text:'æ–°æ–‡æœ¬', 
        left: 100, 
        top: 100, 
        width: 200, 
        height: 60, 
        z_index: 300, 
        font_size: 24, 
        color: '#ffffff',
        stroke_width: 0,
        stroke_color: '#000000'
      });
      renderLayerList();
      selectOverlay(id);
    };

    document.getElementById('addGlassBtn').onclick = () => {
      const id = 'ov_' + Date.now();
      // æ¯›ç»ç’ƒå±‚ï¼šé»˜è®¤ä½ç½®åœ¨ä¸»æ–‡æœ¬æ¡†ä½ç½®ï¼Œä½œä¸ºç‹¬ç«‹çš„æ¯›ç»ç’ƒæ•ˆæœ
      const l = state.layout;
      state.overlays.push({ 
        id, 
        type: 'glass', 
        text: '', 
        left: l.box_left || 520, 
        top: l.box_top || 160, 
        width: l.box_width || 640, 
        height: l.box_height || 340, 
        z_index: 195,  // åœ¨ä¸»æ–‡æœ¬æ¡†ä¸‹æ–¹
        opacity: 1, 
        glass_strength: 12 
      });
      renderLayerList();
      selectOverlay(id);
    };

    document.getElementById('addImageOverlayBtn').onclick = () => {
      const id = 'ov_' + Date.now();
      state.overlays.push({ id, type: 'image', image: state.components[0] || '', left: 150, top: 150, width: 100, height: 100, z_index: 310 });
      renderLayerList();
      selectOverlay(id);
    };

    document.getElementById('removeOverlayBtn').onclick = () => {
      state.overlays = state.overlays.filter(o => o.id !== state.selectedOverlayId);
      state.selectedOverlayId = null;
      renderLayerList();
      renderOverlays();
      overlayEditor.style.display = 'none';
    };

    if(saveDefaultBtn) {
      saveDefaultBtn.onclick = async () => {
        state.layout.text_overlays = state.overlays;
        if(state.layout.character_role && state.layout.character_role !== '__auto__') {
          state.layout.character_asset = '__auto__';
          if(inputs.charAsset) inputs.charAsset.value = '__auto__';
        }
        setStatus('æ­£åœ¨ä¿å­˜é»˜è®¤å¸ƒå±€...');
        try {
          const res = await fetch(`/api/config${suffix}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', ...authHeader },
            body: JSON.stringify({ layout: state.layout })
          });
          if(!res.ok) {
            const msg = await res.text();
            throw new Error(msg || 'ä¿å­˜å¤±è´¥');
          }
          await res.json();
          setCurrentPreset(null);
          renderPresetOptions();
          setStatus('é»˜è®¤å¸ƒå±€å·²ä¿å­˜');
        } catch(e) {
          setStatus(e.message || 'ä¿å­˜å¤±è´¥', true);
        }
      };
    }

    if(savePresetBtn) {
      savePresetBtn.onclick = async () => {
        const presetName = window.prompt('è¯·è¾“å…¥æ–°çš„é¢„è®¾åç§°', state.currentPresetName || '');
        if(presetName === null) {
          setStatus('å·²å–æ¶ˆä¿å­˜');
          return;
        }
        await savePresetLayout(presetName, undefined);
      };
    }

    if(overridePresetBtn) {
      overridePresetBtn.onclick = async () => {
        if(!state.currentPresetSlug) {
          setStatus('è¯·å…ˆåº”ç”¨è¦è¦†ç›–çš„é¢„è®¾', true);
          return;
        }
        await savePresetLayout(state.currentPresetName || state.currentPresetSlug, 'å½“å‰é¢„è®¾å·²æ›´æ–°');
      };
    }
    if(loadPresetBtn) {
      loadPresetBtn.onclick = async () => {
        const slug = presetSelect ? presetSelect.value : '';
        if(!slug) {
          setStatus('è¯·å…ˆé€‰æ‹©é¢„è®¾', true);
          return;
        }
        try {
          const res = await fetch(`/api/presets/load${suffix}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json', ...authHeader },
            body: JSON.stringify({ name: slug })
          });
          if(!res.ok) {
            const msg = await res.text();
            throw new Error(msg || 'åŠ è½½å¤±è´¥');
          }
          const data = await res.json();
          state.layout = data.layout || state.layout;
          if(!state.layout.character_role) state.layout.character_role = '__auto__';
          if(state.layout.character_role !== '__auto__') {
            state.layout.character_asset = '__auto__';
          }
          state.overlays = normalizeOverlays(state.layout.text_overlays);
          state.presets = data.presets || state.presets;
          setCurrentPreset(data.preset || { name: data?.preset?.name || slug, slug });
          renderPresetOptions();
          renderRoleOptions();
          syncInputsToState();
          renderLayerList();
          renderCanvas();
          updatePreviewImages();
          setStatus(`å·²åˆ‡æ¢åˆ°é¢„è®¾ï¼š${data?.preset?.name || slug}`);
        } catch(err) {
          setStatus(err.message || 'åŠ è½½é¢„è®¾å¤±è´¥', true);
        }
      };
    }
    
    const uploadComponentBtn = document.getElementById('uploadComponentBtn');
    const uploadFontBtn = document.getElementById('uploadFontBtn');
    const uploadCharacterBtn = document.getElementById('uploadCharacterBtn');

    if(uploadComponentBtn) {
      uploadComponentBtn.onclick = () => uploadFile('component', componentUploadInput);
    }
    if(uploadFontBtn) {
      uploadFontBtn.onclick = () => uploadFile('font', fontUploadInput);
    }
    if(uploadCharacterBtn) {
      uploadCharacterBtn.onclick = () => {
        const emotion = resolveSelectedEmotionSlug();
        const role = resolveSelectedRoleSlug();
        const extra = {};
        if(emotion) extra.emotion = emotion;
        if(role) extra.role = role;
        uploadFile('character', characterUploadInput, extra);
      };
    }

    if(characterEmotionSelect) {
      characterEmotionSelect.addEventListener('change', updateEmotionInputState);
    }
    if(characterRoleUploadSelect) {
      characterRoleUploadSelect.addEventListener('change', updateRoleInputState);
    }
    if(characterRoleSelect) {
      characterRoleSelect.addEventListener('change', () => {
        const selectedRole = characterRoleSelect.value || '__auto__';
        state.layout.character_role = selectedRole;
        if(selectedRole !== '__auto__') {
          state.layout.character_asset = '__auto__';
          if(inputs.charAsset) inputs.charAsset.value = '__auto__';
        }
        updateFromInputs();
        updatePreviewImages();
      });
    }

    // é¢„è§ˆç”ŸæˆåŠŸèƒ½
    document.getElementById('previewBtn').onclick = async () => {
      setStatus('ç”Ÿæˆé¢„è§ˆä¸­...');
      try {
        const res = await fetch(`/api/preview/generate${suffix}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json', ...authHeader },
          body: JSON.stringify({ 
            text: 'è¿™æ˜¯ä¸€æ®µç¤ºä¾‹æ–‡æœ¬ï¼Œç”¨äºé¢„è§ˆå¯¹è¯æ¡†æ•ˆæœã€‚ä½ å¯ä»¥åœ¨è¿™é‡Œçœ‹åˆ°æ–‡æœ¬çš„æ˜¾ç¤ºæ•ˆæœï¼ŒåŒ…æ‹¬å­—ä½“ã€é¢œè‰²ã€å¤§å°ç­‰è®¾ç½®ã€‚',
            emotion: 'happy'
          }),
        });
        if(!res.ok) throw new Error(await res.text());
        const blob = await res.blob();
        const url = URL.createObjectURL(blob);
        
        // åˆ›å»ºé¢„è§ˆçª—å£
        const previewWindow = window.open('', '_blank');
        previewWindow.document.write(`
          <html>
            <head><title>é¢„è§ˆ</title><style>body{margin:0;display:flex;justify-content:center;align-items:center;min-height:100vh;background:#000;}</style></head>
            <body><img src="${url}" style="max-width:100%;max-height:100vh;" /></body>
          </html>
        `);
        setStatus('é¢„è§ˆç”ŸæˆæˆåŠŸ');
      } catch(err) {
        setStatus('é¢„è§ˆç”Ÿæˆå¤±è´¥: ' + err.message, true);
      }
    };

    // å›¾å±‚ç±»å‹é€‰æ‹©å™¨changeäº‹ä»¶
    const overlayTypeSelect = document.getElementById('overlayTypeSelect');
    if(overlayTypeSelect) {
      overlayTypeSelect.addEventListener('change', () => {
        updateOverlayFromInput();
      });
    }

    // å½“character_assetæˆ–background_assetæ”¹å˜æ—¶æ›´æ–°é¢„è§ˆ
    // æ³¨æ„ï¼šupdateFromInputs()å·²ç»å¤„ç†äº†inputäº‹ä»¶ï¼Œè¿™é‡Œåªå¤„ç†changeäº‹ä»¶ï¼ˆä¸‹æ‹‰é€‰æ‹©ï¼‰
    let lastBgAsset = state.layout.background_asset;
    let lastCharAsset = state.layout.character_asset;
    inputs.charAsset.addEventListener('change', () => {
      const newValue = inputs.charAsset.value;
      if(newValue !== lastCharAsset) {
        lastCharAsset = newValue;
        state.layout.character_asset = newValue;
        updatePreviewImages();
      }
    });
    inputs.bgAsset.addEventListener('change', () => {
      const newValue = inputs.bgAsset.value;
      if(newValue !== lastBgAsset) {
        lastBgAsset = newValue;
        state.layout.background_asset = newValue;
        updatePreviewImages();
      }
    });

    async function uploadFile(type, input, extra = {}) {
      if(!input || !input.files || !input.files[0]) {
        setStatus('è¯·å…ˆé€‰æ‹©è¦ä¸Šä¼ çš„æ–‡ä»¶', true);
        return;
      }
      const file = input.files[0];
      const formData = new FormData();
      formData.append('file', file);
      formData.append('filename', file.name);
      formData.append('kind', type);
      Object.entries(extra || {}).forEach(([key, value]) => {
        if(value !== undefined && value !== null && value !== '') {
          formData.append(key, value);
        }
      });
      setStatus('æ­£åœ¨ä¸Šä¼ ...');
      try {
        const res = await fetch(`/api/components/upload${suffix}`, {
          method: 'POST',
          headers: { ...authHeader },
          body: formData
        });
        if(!res.ok) {
          const msg = await res.text();
          throw new Error(msg || 'ä¸Šä¼ å¤±è´¥');
        }
        setStatus('ä¸Šä¼ æˆåŠŸï¼Œæ­£åœ¨åˆ·æ–°');
        setTimeout(() => location.reload(), 800);
      } catch(err) {
        console.error(err);
        setStatus(`ä¸Šä¼ å¤±è´¥ï¼š${err?.message || err}`, true);
      } finally {
        input.value = '';
      }
    }

    // Init
    window.addEventListener('resize', renderCanvas);
    init();

  </script>
</body>
</html>